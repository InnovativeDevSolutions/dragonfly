---
title: Quick Start
description: Get up and running quickly with ArmaDragonflyClient
---

# Quick Start

This guide will help you get started with ArmaDragonflyClient in minutes with practical examples.

## Initialize the Database

Before using any database functions, initialize the connection:

```sqf
[] call dragonfly_db_fnc_init;
```

::callout{icon="i-lucide-info" color="secondary"}
**Note**: Initialization is automatic when the mod loads, but you can call this function to verify the connection.
::

## Basic Operations

### Store Simple Data

```sqf
// Store a string
["playerName", "John Doe"] call dragonfly_db_fnc_set;

// Store a number
["playerScore", 1500] call dragonfly_db_fnc_set;

// Store an array
["playerInventory", ["ItemMap", "ItemCompass", "ItemWatch"]] call dragonfly_db_fnc_set;
```

### Retrieve Data

```sqf
// Get a value
private _name = ["playerName"] call dragonfly_db_fnc_get;
hint format ["Player: %1", _name];

// Check if key exists
private _exists = ["playerScore"] call dragonfly_db_fnc_exists;
if (_exists > 0) then {
    hint "Player score found!";
};
```

### Delete Data

```sqf
// Delete a single key
["playerName"] call dragonfly_db_fnc_del;

// Delete multiple keys
["key1", "key2", "key3"] call dragonfly_db_fnc_del;
```

## Hash Operations

Hashes are perfect for storing structured player data with multiple fields.

### Store Player Data

```sqf
// Store individual fields
["", "name", name player] call dragonfly_db_fnc_hset;
["", "loadout", getUnitLoadout player] call dragonfly_db_fnc_hset;
["", "position", getPosASL player] call dragonfly_db_fnc_hset;

// Or store multiple fields at once
["", [
    "name", name player,
    "loadout", getUnitLoadout player,
    "position", getPosASL player,
    "direction", getDir player,
    "money", player getVariable ["money", 0]
]] call dragonfly_db_fnc_hmset;
```

::callout{icon="i-lucide-user" color="primary"}
**Context Mode**: When you use an empty string `""` as the key, it automatically uses the player's Steam ID. Perfect for per-player data!
::

### Retrieve Player Data

```sqf
// Get a single field
private _loadout = ["", "loadout"] call dragonfly_db_fnc_hget;
player setUnitLoadout _loadout;

// Get all fields
private _allData = ["", player, "myRestoreFunction"] remoteExec ["dragonfly_db_fnc_hgetall", 2, false];
```

### Working with Specific Players

```sqf
// Store data for a specific player
private _uid = getPlayerUID _somePlayer;
[_uid, "money", 5000] call dragonfly_db_fnc_hset;

// Retrieve it later
private _money = [_uid, "money"] call dragonfly_db_fnc_hget;
```

## List Operations

Lists are perfect for logs, queues, and ordered collections.

### Add Items to a List

```sqf
// Add to the front of the list
["eventLog", str [time, "Mission Started"]] call dragonfly_db_fnc_lpush;

// Add to the back of the list
["chatHistory", str [name player, _message]] call dragonfly_db_fnc_rpush;
```

### Retrieve List Items

```sqf
// Get a specific item by index (0-based)
private _firstEvent = ["eventLog", 0] call dragonfly_db_fnc_lindex;

// Get a range of items
private _recentEvents = ["eventLog", 0, 4] call dragonfly_db_fnc_lrange;
// Returns the first 5 events

// Get all items
private _allEvents = ["eventLog", 0, -1] call dragonfly_db_fnc_lrange;
```

### Modify List Items

```sqf
// Update an item at index
["eventLog", 0, str [time, "Mission Updated"]] call dragonfly_db_fnc_lset;

// Remove an item by index
["eventLog", 2] call dragonfly_db_fnc_lrem;
```

## Multiplayer Usage

In multiplayer, database operations should run on the server.

### Server-Side Operations

```sqf
// Simple operations (no callback needed)
["playerScore", 2000] remoteExec ["dragonfly_db_fnc_set", 2, false];

// Get data with callback
[
    "playerScore",          // Key
    player,                 // Target (return to this player)
    "myCallbackFunction"    // Function to receive the data
] remoteExec ["dragonfly_db_fnc_get", 2, false];
```

### Define Callback Functions

```sqf
// Client-side callback
myCallbackFunction = {
    params ["_data"];
    hint format ["Your score: %1", _data];
};

// More complex callback
myRestoreFunction = {
    params ["_data"];
    
    // Parse hash data
    private _loadout = _data select (_data find "loadout" + 1);
    private _position = _data select (_data find "position" + 1);
    private _money = _data select (_data find "money" + 1);
    
    // Apply to player
    player setUnitLoadout _loadout;
    player setPos _position;
    player setVariable ["money", _money, true];
    
    hint format ["Welcome back! Balance: $%1", _money];
};
```

## Persistence

### Manual Save

DragonflyDB automatically persists data, but you can trigger manual saves:

```sqf
[] call dragonfly_db_fnc_save;
```

::callout{icon="i-lucide-database" color="secondary"}
**Auto-Persistence**: DragonflyDB continuously persists data in the background using snapshots and AOF (Append-Only File) logs.
::

## Complete Example: Player Persistence System

Here's a complete example showing how to save and load player data:

```sqf
// ===== Save player on disconnect =====
addMissionEventHandler ["PlayerDisconnected", {
    params ["_id", "_uid", "_name", "_jip", "_owner", "_idstr"];
    
    // Get player object
    private _player = objectFromNetId _id;
    
    // Store all player data using Steam ID
    [_uid, [
        "name", _name,
        "position", getPosASL _player,
        "direction", getDir _player,
        "loadout", getUnitLoadout _player,
        "money", _player getVariable ["money", 0],
        "rank", _player getVariable ["rank", "Private"],
        "kills", _player getVariable ["kills", 0],
        "deaths", _player getVariable ["deaths", 0],
        "playTime", _player getVariable ["playTime", 0],
        "lastSeen", systemTimeUTC
    ]] call dragonfly_db_fnc_hmset;
    
    // Data is automatically persisted by DragonflyDB
    systemChat format ["%1's data saved", _name];
}];

// ===== Load player on connect =====
addMissionEventHandler ["PlayerConnected", {
    params ["_id", "_uid", "_name", "_jip", "_owner", "_idstr"];
    
    // Check if player data exists
    private _exists = [_uid] call dragonfly_db_fnc_exists;
    
    if (_exists > 0) then {
        // Player has saved data - load it
        [_uid, objectFromNetId _id, {
            params ["_data", "_player"];
            
            // Parse the hash data
            private _position = _data select (_data find "position" + 1);
            private _direction = _data select (_data find "direction" + 1);
            private _loadout = _data select (_data find "loadout" + 1);
            private _money = parseNumber (_data select (_data find "money" + 1));
            private _rank = _data select (_data find "rank" + 1);
            private _kills = parseNumber (_data select (_data find "kills" + 1));
            private _deaths = parseNumber (_data select (_data find "deaths" + 1));
            private _playTime = parseNumber (_data select (_data find "playTime" + 1));
            
            // Restore player state
            _player setPos _position;
            _player setDir _direction;
            _player setUnitLoadout _loadout;
            _player setVariable ["money", _money, true];
            _player setVariable ["rank", _rank, true];
            _player setVariable ["kills", _kills, true];
            _player setVariable ["deaths", _deaths, true];
            _player setVariable ["playTime", _playTime, true];
            
            // Welcome back message
            systemChat format [
                "Welcome back, %1! Rank: %2, Balance: $%3, K/D: %4/%5",
                name _player, _rank, _money, _kills, _deaths
            ];
        }] remoteExec ["dragonfly_db_fnc_hgetall", 2, false];
    } else {
        // New player - initialize default values
        systemChat format ["Welcome, %1! This is your first time.", _name];
    };
}];
```

## Important Notes

### Payload Size Limit

::callout{icon="i-lucide-alert-triangle" color="warning"}
Keep payloads under **20,480 bytes**. This is the maximum size Arma 3's extension interface can handle at once.
::

For larger data, use callbacks to enable automatic chunking:

```sqf
// This will automatically chunk large responses
["bigDataKey", player, "myCallback"] remoteExec ["dragonfly_db_fnc_get", 2, false];
```

### Context Mode Benefits

Using empty string `""` as the key automatically resolves to the player's Steam ID:

```sqf
// These are equivalent:
["", "money", 5000] call dragonfly_db_fnc_hset;
[getPlayerUID player, "money", 5000] call dragonfly_db_fnc_hset;
```

### Performance Tips

1. **Batch operations**: Use `hmset` instead of multiple `hset` calls
2. **Use hashes**: For structured data, hashes are more efficient than multiple keys
3. **Context mode**: Reduces key management overhead
4. **Lists for logs**: Use lists instead of arrays for append-only data

## Next Steps

Now that you know the basics:

- [Core Functions](/api/core/init) - Full API reference for initialization
- [Basic Operations](/api/basic/set) - Complete guide to SET, GET, DELETE
- [Hash Operations](/api/hash/hset) - Detailed hash table documentation
- [List Operations](/api/list/lpush) - Working with ordered lists
